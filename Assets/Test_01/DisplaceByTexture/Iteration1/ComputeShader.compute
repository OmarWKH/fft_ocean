#pragma kernel CSMain
#pragma kernel Initialize
#pragma kernel iDFTRow
#pragma kernel iDFTColumn
#pragma kernel iDFTOneShot;

#pragma enable_d3d11_debug_symbols

#define PI 3.1415926535897932384626433832795

RWTexture2D<float4> RT_h0;
RWTexture2D<float4> RT_Ph;
RWTexture2D<float4> RT_iDFTRow;
RWTexture2D<float4> RT_iDFTColumnFinal;
RWTexture2D<float4> RT_VertexDisplacement;
RWTexture2D<float4> Result;
RWTexture2D<float4> RT_Debug;
Texture2D<float4> noise_r0;
Texture2D<float4> noise_i0;
Texture2D<float4> noise_r1;
Texture2D<float4> noise_i1;
SamplerState linearClampSampler;
float Time;
uint N; // width/height
uint L; // horizontal dimension?
float A; // constant in P_h(k)
float2 w; // wind direction
int V; // wind speed

const float g = 9.81;

struct complex {
    float real;
    float imag;
};

complex mul(complex a, complex b) {
    complex result;
    result.real = a.real * b.real - a.imag * b.imag;
    result.imag = a.real * b.imag + a.imag * b.real;
    return result;
}

complex add(complex a, complex b) {
    complex result;
    result.real = a.real + b.real;
    result.imag = a.imag + b.imag;
    return result;
}

complex conjugate(complex a) {
    complex result;
    result.real = a.real;
    result.imag = -a.imag;
    return result;
}

// Box-Muller-Method, FJs thesis
float4 gaussRND(uint3 id)
{
    float2 texCoord = float2(id.xy) / float(N);
    float noise00 = clamp(noise_r0.SampleLevel(linearClampSampler, texCoord, 0).r, 0.001, 1.0); // already clamped by sampler?
    float noise01 = clamp(noise_i0.SampleLevel(linearClampSampler, texCoord, 0).r, 0.001, 1.0);
    float noise02 = clamp(noise_r1.SampleLevel(linearClampSampler, texCoord, 0).r, 0.001, 1.0);
    float noise03 = clamp(noise_i1.SampleLevel(linearClampSampler, texCoord, 0).r, 0.001, 1.0);
    float u0 = 2.0*PI*noise00;
    float v0 = sqrt(-2.0 * log(noise01));
    float u1 = 2.0*PI* noise02;
    float v1 = sqrt(-2.0 * log(noise03));
    float4 rnd = float4(v0 * cos(u0), v0 * sin(u0), v1 * cos(u1), v1 * sin(u1));
    return rnd;
}

// Philips
float v2_sqrt_P_h_over_sqrt2(float2 k) {
    float k_mag = length(k);
    if (k_mag < 0.00001) k_mag = 0.00001; // suppress smaller waves?
    float k_mag_sq = k_mag * k_mag;
    float L_ = V * V / g; // largest wave at wind speed V
    float result = clamp(
        sqrt(
            (A/(k_mag_sq * k_mag_sq))
            * pow(dot(normalize(k), normalize(w)), 6.0)
            * exp(-(1.0/(k_mag_sq * L_ * L_)))
            * exp(-k_mag_sq*pow(L/2000.0,2.0))) / sqrt(2.0)
    , -4000, 4000);
    return result;
}

complex h_0(uint3 id, float spectrum)
{
    complex result;
    float4 random = gaussRND(id);
    result.real = random.x * spectrum;
    result.imag = random.y * spectrum;
    return result;
}

[numthreads(16,16,1)]
void Initialize(uint3 id : SV_DispatchThreadID) {
    // if (id.x > (N/2) || id.y > (N/2)) return;
    float2 nm = id.xy - N / 2.0; // -N/2 <= n & m <= N/2
    float2 k = float2(2.0 * PI * nm.x / L, 2.0 * PI * nm.y / L); // wavevector
    float spectrum = v2_sqrt_P_h_over_sqrt2(k);
    complex h_0_k = h_0(id, spectrum);
    RT_Ph[id.xy] = float4(spectrum, 0, 0, 0);
    RT_h0[id.xy] = float4(h_0_k.real, h_0_k.imag, 0, 0);

    // uint2 mirror = uint2((N - id.x) % N, (N - id.y) % N);
    // complex conj = conjugate(h_0_k);
    // RT_h0[mirror.xy] = float4(conj.real, conj.imag, 0, 0);
}

void Finalize(uint3 id : SV_DispatchThreadID) {
    RT_VertexDisplacement[id.xy] = float4(0.0, RT_iDFTColumnFinal[id.xy].x, 0.0, 0.0);
}

// real valued because of Hermitian symmetry?
[numthreads(16,16,1)]
void iDFTOneShot(uint3 id : SV_DispatchThreadID)
{
    uint n = id.x;
    uint m = id.y;

    complex result;
    result.real = 0.0;
    result.imag = 0.0;

    for (uint k = 0; k < N; k++) {
        complex innerResult;
        innerResult.real = 0.0;
        innerResult.imag = 0.0;
        for (uint l = 0; l < N; l++) {
            float2 input = RT_h0[uint2(k, l)].xy;
            complex complexInput;
            complexInput.real = input.x;
            complexInput.imag = input.y;
            float angle = ((2.0 * PI * k * float(n) - PI * N * n) / float(N)) + ((2.0 * PI * l * m - PI * N * m) / float(N));
            // float angle = 2.0 * PI * ((float(k) * n + float(l) * m) / float(N));
            complex phaser;
            phaser.real = cos(angle);
            phaser.imag = -sin(angle);
            innerResult = add(innerResult, mul(complexInput, phaser));
        }
        result = add(result, innerResult);
        // RT_Debug[id.xy] = float4(innerResult.real, innerResult.imag, result.real, result.imag);
    }

    RT_iDFTColumnFinal[id.xy] = float4(result.real / float(N * N), result.imag / float(N * N), 0.0, 0.0);
    Finalize(id);
}

// not used, incorrect
float sqrt_P_h_over_sqrt2(float2 k) {
    float k_mag = length(k);
    float l = 0.00001; // not the same l?
    if (k_mag < 0.00001) k_mag = 0.00001; // suppress smaller waves?
    float k_mag_sq = k_mag * k_mag;
    float L_ = V * V / g; // largest wave at wind speed V
    float result =  sqrt(A / (k_mag_sq * k_mag_sq)) // clamp?
                    * sqrt(exp(-1.0 / (k_mag_sq * L * L)))
                    * length(dot(normalize(k), normalize(w))) // ^6?
                    * sqrt(exp(-1.0 * k_mag_sq * l * l));
    return result / sqrt(2.0);
}

// not used
[numthreads(16,16,1)]
void iDFTRow(uint3 id : SV_DispatchThreadID)
{
    complex result;
    result.real = 0.0;
    result.imag = 0.0;
    
    for (uint n = 0; n < N; n++) {
        float2 input = RT_h0[float2(n, id.y)].xy;
        complex complexInput;
        complexInput.real = input.x;
        complexInput.imag = input.y;
        float angle = 2.0 * PI * id.x * n / float(N);
        complex phaser;
        phaser.real = cos(angle);
        phaser.imag = sin(angle);
        result = add(result, mul(complexInput, phaser));
    }
    
    RT_iDFTRow[id.xy] = float4(result.real / float(N), result.imag / float(N), 0.0, 0.0);
}

// not used
[numthreads(16,16,1)]
void iDFTColumn(uint3 id : SV_DispatchThreadID)
{
    complex result;
    result.real = 0.0;
    result.imag = 0.0;
    
    for (uint n = 0; n < N; n++) {
        float2 input = RT_iDFTRow[float2(id.x, n)].xy;
        complex complexInput;
        complexInput.real = input.x;
        complexInput.imag = input.y;
        float angle = 2.0 * PI * id.y * n / float(N);
        complex phaser;
        phaser.real = cos(angle);
        phaser.imag = sin(angle);
        result = add(result, mul(complexInput, phaser));
    }
    
    RT_iDFTColumnFinal[id.xy] = float4(result.real / float(N), result.imag / float(N), 0.0, 0.0);
    Finalize(id);
}

// not used
[numthreads(16,16,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float x = 0;
    float y = sin(id.x + 1) / 2.0;
    float z = 0;
    Result[id.xy] = float4(x, y, z, 0);
}